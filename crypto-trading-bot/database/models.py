"""
Database Models

This module defines all database models and tables for the trading bot system.
"""

import logging
from datetime import datetime
from typing import Optional, Dict, Any, List
from enum import Enum

try:
    from sqlalchemy import Column, Integer, String, Float, DateTime, Text, Boolean, JSON, ForeignKey, Index
    from sqlalchemy.orm import relationship
    from sqlalchemy.ext.declarative import declarative_base
    from .connection import Base
    SQLALCHEMY_AVAILABLE = True
except ImportError:
    SQLALCHEMY_AVAILABLE = False
    # Create dummy base for when SQLAlchemy is not available
    class Base:
        pass

logger = logging.getLogger(__name__)

# Enums for consistent data types
class LogLevel(Enum):
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

class TradeDirection(Enum):
    BUY = "BUY"
    SELL = "SELL"
    LONG = "LONG"
    SHORT = "SHORT"

class TradeStatus(Enum):
    PENDING = "PENDING"
    OPEN = "OPEN"
    CLOSED = "CLOSED"
    CANCELLED = "CANCELLED"

class SignalType(Enum):
    BUY = "BUY"
    SELL = "SELL" 
    HOLD = "HOLD"

# Database Models (only if SQLAlchemy is available)
if SQLALCHEMY_AVAILABLE:
    
    class Trade(Base):
        """Trade execution records"""
        __tablename__ = 'trades'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Trade identification
        symbol = Column(String(20), nullable=False, index=True)
        strategy_id = Column(String(50), nullable=False, index=True)
        
        # Trade details
        direction = Column(String(10), nullable=False)  # BUY, SELL, LONG, SHORT
        quantity = Column(Float, nullable=False)
        entry_price = Column(Float, nullable=False)
        exit_price = Column(Float, nullable=True)
        
        # P&L and performance
        pnl = Column(Float, nullable=True)
        pnl_percentage = Column(Float, nullable=True)
        commission = Column(Float, default=0.0)
        slippage = Column(Float, default=0.0)
        
        # Risk management
        stop_loss = Column(Float, nullable=True)
        take_profit = Column(Float, nullable=True)
        risk_amount = Column(Float, nullable=True)
        reward_amount = Column(Float, nullable=True)
        
        # Timing
        entry_time = Column(DateTime, nullable=False, default=datetime.utcnow)
        exit_time = Column(DateTime, nullable=True)
        hold_duration = Column(Float, nullable=True)  # in hours
        
        # Status and metadata
        status = Column(String(20), default=TradeStatus.PENDING.value)
        exit_reason = Column(String(50), nullable=True)  # STOP_LOSS, TAKE_PROFIT, MANUAL, etc.
        notes = Column(Text, nullable=True)
        
        # Additional data
        market_data = Column(JSON, nullable=True)  # Market conditions at trade time
        signal_data = Column(JSON, nullable=True)  # Original signal data
        
        # Indexes for performance
        __table_args__ = (
            Index('idx_trades_symbol_time', 'symbol', 'entry_time'),
            Index('idx_trades_strategy_time', 'strategy_id', 'entry_time'),
            Index('idx_trades_status', 'status'),
        )
        
        def __repr__(self):
            return f"<Trade(id={self.id}, symbol={self.symbol}, direction={self.direction}, pnl={self.pnl})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert trade to dictionary"""
            return {
                'id': self.id,
                'symbol': self.symbol,
                'strategy_id': self.strategy_id,
                'direction': self.direction,
                'quantity': self.quantity,
                'entry_price': self.entry_price,
                'exit_price': self.exit_price,
                'pnl': self.pnl,
                'pnl_percentage': self.pnl_percentage,
                'commission': self.commission,
                'stop_loss': self.stop_loss,
                'take_profit': self.take_profit,
                'entry_time': self.entry_time.isoformat() if self.entry_time else None,
                'exit_time': self.exit_time.isoformat() if self.exit_time else None,
                'hold_duration': self.hold_duration,
                'status': self.status,
                'exit_reason': self.exit_reason,
                'notes': self.notes
            }
    
    class Signal(Base):
        """Trading signals generated by strategies"""
        __tablename__ = 'signals'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Signal identification
        symbol = Column(String(20), nullable=False, index=True)
        strategy_id = Column(String(50), nullable=False, index=True)
        
        # Signal details
        signal_type = Column(String(10), nullable=False)  # BUY, SELL, HOLD
        confidence = Column(Float, nullable=False)
        entry_price = Column(Float, nullable=False)
        
        # Risk parameters
        stop_loss = Column(Float, nullable=True)
        take_profit = Column(Float, nullable=True)
        risk_reward_ratio = Column(Float, nullable=True)
        
        # Signal metadata
        reasoning = Column(JSON, nullable=True)  # List of reasons
        indicators = Column(JSON, nullable=True)  # Technical indicators
        market_condition = Column(String(20), nullable=True)
        
        # Timing and status
        generated_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
        expires_at = Column(DateTime, nullable=True)
        executed = Column(Boolean, default=False)
        executed_at = Column(DateTime, nullable=True)
        
        # Execution tracking
        trade_id = Column(Integer, ForeignKey('trades.id'), nullable=True)
        trade = relationship("Trade", backref="signal")
        
        # Additional data
        context = Column(JSON, nullable=True)
        quality_score = Column(Float, nullable=True)
        
        __table_args__ = (
            Index('idx_signals_symbol_time', 'symbol', 'generated_at'), 
            Index('idx_signals_strategy_time', 'strategy_id', 'generated_at'),
            Index('idx_signals_executed', 'executed'),
        )
        
        def __repr__(self):
            return f"<Signal(id={self.id}, symbol={self.symbol}, type={self.signal_type}, confidence={self.confidence})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert signal to dictionary"""
            return {
                'id': self.id,
                'symbol': self.symbol,
                'strategy_id': self.strategy_id,
                'signal_type': self.signal_type,
                'confidence': self.confidence,
                'entry_price': self.entry_price,
                'stop_loss': self.stop_loss,
                'take_profit': self.take_profit,
                'risk_reward_ratio': self.risk_reward_ratio,
                'reasoning': self.reasoning,
                'indicators': self.indicators,
                'market_condition': self.market_condition,
                'generated_at': self.generated_at.isoformat() if self.generated_at else None,
                'expires_at': self.expires_at.isoformat() if self.expires_at else None,
                'executed': self.executed,
                'executed_at': self.executed_at.isoformat() if self.executed_at else None,
                'trade_id': self.trade_id,
                'quality_score': self.quality_score
            }
    
    class PortfolioSnapshot(Base):
        """Portfolio value snapshots for performance tracking"""
        __tablename__ = 'portfolio_snapshots'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Portfolio values
        total_value = Column(Float, nullable=False)
        cash_balance = Column(Float, nullable=False)
        invested_amount = Column(Float, nullable=False)
        unrealized_pnl = Column(Float, default=0.0)
        realized_pnl = Column(Float, default=0.0)
        
        # Position info
        active_positions = Column(Integer, default=0)
        largest_position_pct = Column(Float, default=0.0)
        
        # Performance metrics
        daily_pnl = Column(Float, default=0.0)
        total_return_pct = Column(Float, default=0.0)
        
        # Risk metrics
        current_drawdown = Column(Float, default=0.0)
        portfolio_beta = Column(Float, nullable=True)
        
        # Timestamp
        snapshot_time = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
        
        # Additional data
        positions_data = Column(JSON, nullable=True)  # Detailed position information
        market_data = Column(JSON, nullable=True)     # Market conditions
        
        __table_args__ = (
            Index('idx_portfolio_time', 'snapshot_time'),
        )
        
        def __repr__(self):
            return f"<PortfolioSnapshot(id={self.id}, value={self.total_value}, time={self.snapshot_time})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert snapshot to dictionary"""
            return {
                'id': self.id,
                'total_value': self.total_value,
                'cash_balance': self.cash_balance,
                'invested_amount': self.invested_amount,
                'unrealized_pnl': self.unrealized_pnl,
                'realized_pnl': self.realized_pnl,
                'active_positions': self.active_positions,
                'daily_pnl': self.daily_pnl,
                'total_return_pct': self.total_return_pct,
                'current_drawdown': self.current_drawdown,
                'snapshot_time': self.snapshot_time.isoformat() if self.snapshot_time else None
            }
    
    class SystemLog(Base):
        """System logging table"""
        __tablename__ = 'system_logs'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Log details
        level = Column(String(10), nullable=False, index=True)
        logger_name = Column(String(100), nullable=False)
        message = Column(Text, nullable=False)
        
        # Context
        module = Column(String(100), nullable=True)
        function = Column(String(100), nullable=True)
        line_number = Column(Integer, nullable=True)
        
        # Timing
        timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
        
        # Additional data
        extra_data = Column(JSON, nullable=True)
        exception_info = Column(Text, nullable=True)
        
        __table_args__ = (
            Index('idx_logs_level_time', 'level', 'timestamp'),
            Index('idx_logs_logger_time', 'logger_name', 'timestamp'),
        )
        
        def __repr__(self):
            return f"<SystemLog(id={self.id}, level={self.level}, message={self.message[:50]}...)>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert log to dictionary"""
            return {
                'id': self.id,
                'level': self.level,
                'logger_name': self.logger_name,
                'message': self.message,
                'module': self.module,
                'function': self.function,
                'timestamp': self.timestamp.isoformat() if self.timestamp else None,
                'extra_data': self.extra_data
            }
    
    class StrategyPerformance(Base):
        """Strategy performance tracking"""
        __tablename__ = 'strategy_performance'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Strategy identification
        strategy_id = Column(String(50), nullable=False, index=True)
        symbol = Column(String(20), nullable=True, index=True)  # None for overall performance
        
        # Performance period
        period_start = Column(DateTime, nullable=False)
        period_end = Column(DateTime, nullable=False)
        period_type = Column(String(20), nullable=False)  # DAILY, WEEKLY, MONTHLY, etc.
        
        # Trading metrics
        total_trades = Column(Integer, default=0)
        winning_trades = Column(Integer, default=0)
        losing_trades = Column(Integer, default=0)
        win_rate = Column(Float, default=0.0)
        
        # P&L metrics
        total_pnl = Column(Float, default=0.0)
        gross_profit = Column(Float, default=0.0)
        gross_loss = Column(Float, default=0.0)
        profit_factor = Column(Float, default=0.0)
        
        # Risk metrics
        max_drawdown = Column(Float, default=0.0)
        sharpe_ratio = Column(Float, default=0.0)
        sortino_ratio = Column(Float, default=0.0)
        
        # Trade statistics
        avg_winning_trade = Column(Float, default=0.0)
        avg_losing_trade = Column(Float, default=0.0)
        largest_winning_trade = Column(Float, default=0.0)
        largest_losing_trade = Column(Float, default=0.0)
        
        # Hold time statistics
        avg_hold_time = Column(Float, default=0.0)  # in hours
        
        # Signal metrics
        total_signals = Column(Integer, default=0)
        signals_executed = Column(Integer, default=0)
        avg_signal_quality = Column(Float, default=0.0)
        
        # Timestamp
        calculated_at = Column(DateTime, nullable=False, default=datetime.utcnow)
        
        __table_args__ = (
            Index('idx_strategy_perf_id_period', 'strategy_id', 'period_type', 'period_start'),
            Index('idx_strategy_perf_symbol', 'symbol', 'period_start') if 'symbol' else None,
        )
        
        def __repr__(self):
            return f"<StrategyPerformance(strategy={self.strategy_id}, period={self.period_type}, win_rate={self.win_rate})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert performance to dictionary"""
            return {
                'id': self.id,
                'strategy_id': self.strategy_id,
                'symbol': self.symbol,
                'period_start': self.period_start.isoformat() if self.period_start else None,
                'period_end': self.period_end.isoformat() if self.period_end else None,
                'period_type': self.period_type,
                'total_trades': self.total_trades,
                'win_rate': self.win_rate,
                'total_pnl': self.total_pnl,
                'profit_factor': self.profit_factor,
                'max_drawdown': self.max_drawdown,
                'sharpe_ratio': self.sharpe_ratio,
                'avg_hold_time': self.avg_hold_time
            }
    
    class MarketData(Base):
        """Market data storage for backtesting and analysis"""
        __tablename__ = 'market_data'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Market identification
        symbol = Column(String(20), nullable=False, index=True)
        timeframe = Column(String(10), nullable=False)  # 1m, 5m, 1h, 1d, etc.
        
        # OHLCV data
        timestamp = Column(DateTime, nullable=False, index=True)
        open_price = Column(Float, nullable=False)
        high_price = Column(Float, nullable=False)
        low_price = Column(Float, nullable=False)
        close_price = Column(Float, nullable=False)
        volume = Column(Float, nullable=False)
        
        # Derived metrics
        price_change = Column(Float, nullable=True)
        price_change_pct = Column(Float, nullable=True)
        
        # Technical indicators (pre-calculated)
        sma_20 = Column(Float, nullable=True)
        ema_12 = Column(Float, nullable=True)
        rsi_14 = Column(Float, nullable=True)
        
        # Additional data
        quote_volume = Column(Float, nullable=True)
        trade_count = Column(Integer, nullable=True)
        
        __table_args__ = (
            Index('idx_market_data_symbol_time', 'symbol', 'timeframe', 'timestamp'),
        )
        
        def __repr__(self):
            return f"<MarketData(symbol={self.symbol}, timeframe={self.timeframe}, close={self.close_price})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert market data to dictionary"""
            return {
                'id': self.id,
                'symbol': self.symbol,
                'timeframe': self.timeframe,
                'timestamp': self.timestamp.isoformat() if self.timestamp else None,
                'open': self.open_price,
                'high': self.high_price,
                'low': self.low_price,
                'close': self.close_price,
                'volume': self.volume,
                'price_change_pct': self.price_change_pct
            }
    
    class RiskEvent(Base):
        """Risk management events and circuit breaker activations"""
        __tablename__ = 'risk_events'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        
        # Event identification
        event_type = Column(String(50), nullable=False, index=True)  # CIRCUIT_BREAKER, RISK_LIMIT, etc.
        severity = Column(String(20), nullable=False)  # LOW, MEDIUM, HIGH, CRITICAL
        
        # Event details
        description = Column(Text, nullable=False)
        trigger_value = Column(Float, nullable=True)
        threshold_value = Column(Float, nullable=True)
        
        # Context
        symbol = Column(String(20), nullable=True)
        strategy_id = Column(String(50), nullable=True)
        
        # Actions taken
        action_taken = Column(String(100), nullable=True)
        positions_closed = Column(Integer, default=0)
        trading_halted = Column(Boolean, default=False)
        
        # Timing
        event_time = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
        resolved_time = Column(DateTime, nullable=True)
        
        # Additional data
        portfolio_impact = Column(JSON, nullable=True)
        metadata = Column(JSON, nullable=True)
        
        __table_args__ = (
            Index('idx_risk_events_type_time', 'event_type', 'event_time'),
            Index('idx_risk_events_severity', 'severity'),
        )
        
        def __repr__(self):
            return f"<RiskEvent(id={self.id}, type={self.event_type}, severity={self.severity})>"
        
        def to_dict(self) -> Dict[str, Any]:
            """Convert risk event to dictionary"""
            return {
                'id': self.id,
                'event_type': self.event_type,
                'severity': self.severity,
                'description': self.description,
                'trigger_value': self.trigger_value,
                'threshold_value': self.threshold_value,
                'symbol': self.symbol,
                'strategy_id': self.strategy_id,
                'action_taken': self.action_taken,
                'event_time': self.event_time.isoformat() if self.event_time else None,
                'resolved_time': self.resolved_time.isoformat() if self.resolved_time else None,
                'trading_halted': self.trading_halted
            }

else:
    # Dummy models when SQLAlchemy is not available
    class Trade:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class Signal:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class PortfolioSnapshot:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class SystemLog:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class StrategyPerformance:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class MarketData:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}
    
    class RiskEvent:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def to_dict(self):
            return {key: value for key, value in self.__dict__.items()}

# Database helper functions
async def create_trade_record(trade_data: Dict[str, Any]) -> Optional[int]:
    """Create a new trade record"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            logger.warning("Cannot create trade record - SQLAlchemy not available")
            return None
        
        from .connection import db_manager
        
        async with db_manager.get_async_session() as session:
            trade = Trade(
                symbol=trade_data.get('symbol'),
                strategy_id=trade_data.get('strategy_id'),
                direction=trade_data.get('direction'),
                quantity=trade_data.get('quantity'),
                entry_price=trade_data.get('entry_price'),
                exit_price=trade_data.get('exit_price'),
                pnl=trade_data.get('pnl'),
                stop_loss=trade_data.get('stop_loss'),
                take_profit=trade_data.get('take_profit'),
                entry_time=trade_data.get('entry_time', datetime.utcnow()),
                exit_time=trade_data.get('exit_time'),
                status=trade_data.get('status', TradeStatus.PENDING.value),
                exit_reason=trade_data.get('exit_reason'),
                signal_data=trade_data.get('signal_data')
            )
            
            session.add(trade)
            await session.flush()
            trade_id = trade.id
            await session.commit()
            
            return trade_id
            
    except Exception as e:
        logger.error(f"Error creating trade record: {e}")
        return None

async def update_trade_record(trade_id: int, update_data: Dict[str, Any]) -> bool:
    """Update an existing trade record"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return False
        
        from .connection import db_manager
        
        async with db_manager.get_async_session() as session:
            trade = await session.get(Trade, trade_id)
            if trade:
                for key, value in update_data.items():
                    if hasattr(trade, key):
                        setattr(trade, key, value)
                
                await session.commit()
                return True
            
            return False
            
    except Exception as e:
        logger.error(f"Error updating trade record: {e}")
        return False

async def create_signal_record(signal_data: Dict[str, Any]) -> Optional[int]:
    """Create a new signal record"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return None
        
        from .connection import db_manager
        
        async with db_manager.get_async_session() as session:
            signal = Signal(
                symbol=signal_data.get('symbol'),
                strategy_id=signal_data.get('strategy_id'),
                signal_type=signal_data.get('signal_type'),
                confidence=signal_data.get('confidence'),
                entry_price=signal_data.get('entry_price'),
                stop_loss=signal_data.get('stop_loss'),
                take_profit=signal_data.get('take_profit'),
                reasoning=signal_data.get('reasoning'),
                indicators=signal_data.get('indicators'),
                market_condition=signal_data.get('market_condition'),
                expires_at=signal_data.get('expires_at'),
                quality_score=signal_data.get('quality_score')
            )
            
            session.add(signal)
            await session.flush()
            signal_id = signal.id
            await session.commit()
            
            return signal_id
            
    except Exception as e:
        logger.error(f"Error creating signal record: {e}")
        return None

async def create_portfolio_snapshot(snapshot_data: Dict[str, Any]) -> Optional[int]:
    """Create a portfolio snapshot record"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return None
        
        from .connection import db_manager
        
        async with db_manager.get_async_session() as session:
            snapshot = PortfolioSnapshot(
                total_value=snapshot_data.get('total_value'),
                cash_balance=snapshot_data.get('cash_balance'),
                invested_amount=snapshot_data.get('invested_amount'),
                unrealized_pnl=snapshot_data.get('unrealized_pnl', 0),
                realized_pnl=snapshot_data.get('realized_pnl', 0),
                active_positions=snapshot_data.get('active_positions', 0),
                daily_pnl=snapshot_data.get('daily_pnl', 0),
                total_return_pct=snapshot_data.get('total_return_pct', 0),
                current_drawdown=snapshot_data.get('current_drawdown', 0),
                positions_data=snapshot_data.get('positions_data'),
                market_data=snapshot_data.get('market_data')
            )
            
            session.add(snapshot)
            await session.flush()
            snapshot_id = snapshot.id
            await session.commit()
            
            return snapshot_id
            
    except Exception as e:
        logger.error(f"Error creating portfolio snapshot: {e}")
        return None

async def log_system_message(level: str, logger_name: str, message: str, 
                           extra_data: Dict[str, Any] = None) -> bool:
    """Log a system message"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return False
        
        from .connection import db_manager
        
        async with db_manager.get_async_session() as session:
            log_entry = SystemLog(
                level=level,
                logger_name=logger_name,
                message=message,
                extra_data=extra_data
            )
            
            session.add(log_entry)
            await session.commit()
            
            return True
            
    except Exception as e:
        logger.error(f"Error logging system message: {e}")
        return False

async def get_trades_by_strategy(strategy_id: str, limit: int = 100) -> List[Dict[str, Any]]:
    """Get trades for a specific strategy"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return []
        
        from .connection import db_manager
        from sqlalchemy import desc
        
        async with db_manager.get_async_session() as session:
            result = await session.execute(
                session.query(Trade)
                .filter(Trade.strategy_id == strategy_id)
                .order_by(desc(Trade.entry_time))
                .limit(limit)
            )
            
            trades = result.scalars().all()
            return [trade.to_dict() for trade in trades]
            
    except Exception as e:
        logger.error(f"Error getting trades by strategy: {e}")
        return []

async def get_recent_signals(symbol: str = None, limit: int = 50) -> List[Dict[str, Any]]:
    """Get recent signals"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return []
        
        from .connection import db_manager
        from sqlalchemy import desc
        
        async with db_manager.get_async_session() as session:
            query = session.query(Signal)
            
            if symbol:
                query = query.filter(Signal.symbol == symbol)
            
            result = await session.execute(
                query.order_by(desc(Signal.generated_at)).limit(limit)
            )
            
            signals = result.scalars().all()
            return [signal.to_dict() for signal in signals]
            
    except Exception as e:
        logger.error(f"Error getting recent signals: {e}")
        return []

async def get_portfolio_history(days: int = 7) -> List[Dict[str, Any]]:
    """Get portfolio history for specified days"""
    try:
        if not SQLALCHEMY_AVAILABLE:
            return []
        
        from .connection import db_manager
        from sqlalchemy import desc
        from datetime import timedelta
        
        start_date = datetime.utcnow() - timedelta(days=days)
        
        async with db_manager.get_async_session() as session:
            result = await session.execute(
                session.query(PortfolioSnapshot)
                .filter(PortfolioSnapshot.snapshot_time >= start_date)
                .order_by(desc(PortfolioSnapshot.snapshot_time))
            )
            
            snapshots = result.scalars().all()
            return [snapshot.to_dict() for snapshot in snapshots]
            
    except Exception as e:
        logger.error(f"Error getting portfolio history: {e}")
        return []

# Model registry for dynamic access
MODEL_REGISTRY = {
    'Trade': Trade,
    'Signal': Signal,
    'PortfolioSnapshot': PortfolioSnapshot,
    'SystemLog': SystemLog,
    'StrategyPerformance': StrategyPerformance,
    'MarketData': MarketData,
    'RiskEvent': RiskEvent
}

def get_model_class(model_name: str):
    """Get model class by name"""
    return MODEL_REGISTRY.get(model_name)

# Export availability flag
DATABASE_MODELS_AVAILABLE = SQLALCHEMY_AVAILABLE

# Example usage and testing
async def test_database_models():
    """Test database models"""
    try:
        print("üóÑÔ∏è Database Models Test")
        print("=" * 40)
        
        if SQLALCHEMY_AVAILABLE:
            print("‚úÖ SQLAlchemy models available")
            
            # Test trade creation
            trade_data = {
                'symbol': 'BTC/USDT',
                'strategy_id': 'test_strategy',
                'direction': 'BUY',
                'quantity': 0.01,
                'entry_price': 45000.0,
                'pnl': 100.0
            }
            
            trade_id = await create_trade_record(trade_data)
            if trade_id:
                print(f"‚úÖ Trade record created with ID: {trade_id}")
            else:
                print("‚ùå Failed to create trade record")
            
            # Test signal creation
            signal_data = {
                'symbol': 'ETH/USDT',
                'strategy_id': 'test_strategy',
                'signal_type': 'BUY',
                'confidence': 85.0,
                'entry_price': 3000.0,
                'reasoning': ['Test signal']
            }
            
            signal_id = await create_signal_record(signal_data)
            if signal_id:
                print(f"‚úÖ Signal record created with ID: {signal_id}")
            else:
                print("‚ùå Failed to create signal record")
            
            # Test portfolio snapshot
            snapshot_data = {
                'total_value': 10500.0,
                'cash_balance': 5000.0,
                'invested_amount': 5500.0,
                'active_positions': 2
            }
            
            snapshot_id = await create_portfolio_snapshot(snapshot_data)
            if snapshot_id:
                print(f"‚úÖ Portfolio snapshot created with ID: {snapshot_id}")
            else:
                print("‚ùå Failed to create portfolio snapshot")
            
        else:
            print("‚ö†Ô∏è SQLAlchemy not available - using dummy models")
            
            # Test dummy models
            trade = Trade(symbol='BTC/USDT', pnl=100)
            trade_dict = trade.to_dict()
            print(f"‚úÖ Dummy trade model works: {trade_dict}")
        
        print("‚úÖ Database models test completed")
        
    except Exception as e:
        print(f"‚ùå Database models test failed: {e}")

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_database_models())