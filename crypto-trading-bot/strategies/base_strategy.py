"""
Base Strategy Framework

This module provides the base classes and interfaces for all trading strategies.
All trading strategies should inherit from BaseStrategy and implement the required methods.
"""

import asyncio
import logging
import pandas as pd
import numpy as np
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union, Tuple
from datetime import datetime, timedelta
from enum import Enum
import json

logger = logging.getLogger(__name__)

class SignalType(Enum):
    """Trading signal types"""
    BUY = "BUY"
    SELL = "SELL"
    LONG = "LONG"
    SHORT = "SHORT"
    HOLD = "HOLD"
    CLOSE = "CLOSE"

class SignalStrength(Enum):
    """Signal strength levels"""
    WEAK = "WEAK"
    MODERATE = "MODERATE"
    STRONG = "STRONG"
    VERY_STRONG = "VERY_STRONG"

class MarketCondition(Enum):
    """Market condition types"""
    TRENDING_UP = "TRENDING_UP"
    TRENDING_DOWN = "TRENDING_DOWN"
    SIDEWAYS = "SIDEWAYS"
    VOLATILE = "VOLATILE"
    CONSOLIDATING = "CONSOLIDATING"
    BREAKOUT = "BREAKOUT"

@dataclass
class TradingSignal:
    """
    Represents a trading signal generated by a strategy
    """
    # Basic signal information
    symbol: str
    signal_type: SignalType
    confidence: float  # 0-100
    entry_price: float
    
    # Risk management
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    risk_reward_ratio: Optional[float] = None
    
    # Signal details
    reasoning: List[str] = field(default_factory=list)
    indicators: Dict[str, Any] = field(default_factory=dict)
    market_condition: Optional[MarketCondition] = None
    signal_strength: Optional[SignalStrength] = None
    
    # Metadata
    strategy_id: str = None
    timestamp: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None
    priority: int = 1  # 1-5, higher is more important
    
    # Position sizing
    suggested_position_size: Optional[float] = None
    max_position_size: Optional[float] = None
    
    # Additional context
    timeframe: str = "1h"
    context: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Post-initialization validation and setup"""
        # Validate confidence
        if not 0 <= self.confidence <= 100:
            raise ValueError(f"Confidence must be between 0-100, got {self.confidence}")
        
        # Convert string signal types to enum
        if isinstance(self.signal_type, str):
            self.signal_type = SignalType(self.signal_type.upper())
        
        # Calculate risk-reward ratio if not provided
        if self.stop_loss and self.take_profit and not self.risk_reward_ratio:
            risk = abs(self.entry_price - self.stop_loss)
            reward = abs(self.take_profit - self.entry_price)
            self.risk_reward_ratio = reward / risk if risk > 0 else None
        
        # Set signal strength based on confidence
        if not self.signal_strength:
            if self.confidence >= 85:
                self.signal_strength = SignalStrength.VERY_STRONG
            elif self.confidence >= 70:
                self.signal_strength = SignalStrength.STRONG
            elif self.confidence >= 55:
                self.signal_strength = SignalStrength.MODERATE
            else:
                self.signal_strength = SignalStrength.WEAK
        
        # Set default expiration (1 hour)
        if not self.expires_at:
            self.expires_at = self.timestamp + timedelta(hours=1)
    
    def is_expired(self) -> bool:
        """Check if signal has expired"""
        return datetime.utcnow() > self.expires_at if self.expires_at else False
    
    def is_buy_signal(self) -> bool:
        """Check if this is a buy/long signal"""
        return self.signal_type in [SignalType.BUY, SignalType.LONG]
    
    def is_sell_signal(self) -> bool:
        """Check if this is a sell/short signal"""
        return self.signal_type in [SignalType.SELL, SignalType.SHORT]
    
    def get_signal_quality_score(self) -> float:
        """Calculate overall signal quality score (0-100)"""
        score = self.confidence * 0.6  # Base confidence weight
        
        # Adjust for risk-reward ratio
        if self.risk_reward_ratio:
            if self.risk_reward_ratio >= 2.0:
                score += 15
            elif self.risk_reward_ratio >= 1.5:
                score += 10
            elif self.risk_reward_ratio >= 1.0:
                score += 5
        
        # Adjust for signal strength
        strength_bonus = {
            SignalStrength.VERY_STRONG: 10,
            SignalStrength.STRONG: 5,
            SignalStrength.MODERATE: 0,
            SignalStrength.WEAK: -10
        }
        score += strength_bonus.get(self.signal_strength, 0)
        
        # Adjust for reasoning quality (more detailed reasoning = higher score)
        if len(self.reasoning) >= 3:
            score += 5
        
        return min(100, max(0, score))
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary"""
        return {
            'symbol': self.symbol,
            'signal_type': self.signal_type.value,
            'confidence': self.confidence,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'risk_reward_ratio': self.risk_reward_ratio,
            'reasoning': self.reasoning,
            'indicators': self.indicators,
            'market_condition': self.market_condition.value if self.market_condition else None,
            'signal_strength': self.signal_strength.value if self.signal_strength else None,
            'strategy_id': self.strategy_id,
            'timestamp': self.timestamp.isoformat(),
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'priority': self.priority,
            'suggested_position_size': self.suggested_position_size,
            'timeframe': self.timeframe,
            'context': self.context,
            'quality_score': self.get_signal_quality_score()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """Create signal from dictionary"""
        # Convert timestamps
        if 'timestamp' in data and isinstance(data['timestamp'], str):
            data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        if 'expires_at' in data and isinstance(data['expires_at'], str):
            data['expires_at'] = datetime.fromisoformat(data['expires_at'])
        
        # Convert enums
        if 'signal_type' in data and isinstance(data['signal_type'], str):
            data['signal_type'] = SignalType(data['signal_type'])
        if 'market_condition' in data and isinstance(data['market_condition'], str):
            data['market_condition'] = MarketCondition(data['market_condition'])
        if 'signal_strength' in data and isinstance(data['signal_strength'], str):
            data['signal_strength'] = SignalStrength(data['signal_strength'])
        
        # Remove fields that aren't in the dataclass
        allowed_fields = {f.name for f in cls.__dataclass_fields__.values()}
        filtered_data = {k: v for k, v in data.items() if k in allowed_fields}
        
        return cls(**filtered_data)

@dataclass
class StrategyPerformance:
    """Strategy performance metrics"""
    total_signals: int = 0
    successful_signals: int = 0
    failed_signals: int = 0
    win_rate: float = 0.0
    avg_confidence: float = 0.0
    avg_quality_score: float = 0.0
    total_return: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    last_updated: datetime = field(default_factory=datetime.utcnow)

class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies
    
    All trading strategies must inherit from this class and implement
    the required abstract methods.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy with configuration
        
        Args:
            config: Strategy configuration dictionary
        """
        self.config = config.copy()
        self.strategy_name = self.__class__.__name__
        self.strategy_id = config.get('strategy_id', self.strategy_name.lower())
        
        # Strategy state
        self.is_initialized = False
        self.is_active = True
        self.last_signal_time = None
        
        # Performance tracking
        self.performance = StrategyPerformance()
        self.signal_history = []
        self.max_history_size = config.get('max_history_size', 1000)
        
        # Strategy parameters
        self.min_confidence_threshold = config.get('min_confidence_threshold', 60.0)
        self.max_signals_per_hour = config.get('max_signals_per_hour', 10)
        self.required_data_points = config.get('required_data_points', 20)
        
        # Risk management
        self.max_risk_per_trade = config.get('max_risk_per_trade', 0.02)  # 2%
        self.default_stop_loss_pct = config.get('default_stop_loss_pct', 0.03)  # 3%
        self.default_take_profit_pct = config.get('default_take_profit_pct', 0.06)  # 6%
        
        # Timing constraints
        self.min_time_between_signals = config.get('min_time_between_signals', 300)  # 5 minutes
        self.signal_cooldown_periods = {}  # symbol -> last_signal_time
        
        logger.info(f"Strategy {self.strategy_name} initialized with config: {len(config)} parameters")
    
    async def initialize(self):
        """
        Initialize strategy (override in subclasses for custom initialization)
        """
        try:
            self.is_initialized = True
            logger.info(f"Strategy {self.strategy_name} initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing strategy {self.strategy_name}: {e}")
            raise
    
    @abstractmethod
    async def generate_signal(self, symbol: str, market_data: pd.DataFrame, 
                            current_price: float) -> Optional[TradingSignal]:
        """
        Generate trading signal for given symbol and market data
        
        Args:
            symbol: Trading symbol (e.g., 'BTC/USDT')
            market_data: Historical market data DataFrame
            current_price: Current price of the asset
            
        Returns:
            TradingSignal or None if no signal generated
        """
        pass
    
    async def can_generate_signal(self, symbol: str) -> bool:
        """
        Check if strategy can generate signal for symbol (rate limiting, cooldowns, etc.)
        """
        try:
            # Check if strategy is active
            if not self.is_active or not self.is_initialized:
                return False
            
            # Check cooldown period
            if symbol in self.signal_cooldown_periods:
                last_signal = self.signal_cooldown_periods[symbol]
                time_since_last = (datetime.utcnow() - last_signal).total_seconds()
                if time_since_last < self.min_time_between_signals:
                    return False
            
            # Check hourly signal limit
            recent_signals = [
                s for s in self.signal_history
                if (datetime.utcnow() - s.timestamp).total_seconds() < 3600
            ]
            if len(recent_signals) >= self.max_signals_per_hour:
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error checking signal generation capability: {e}")
            return False
    
    async def validate_signal(self, signal: TradingSignal) -> bool:
        """
        Validate generated signal before returning
        """
        try:
            # Check confidence threshold
            if signal.confidence < self.min_confidence_threshold:
                return False
            
            # Validate prices
            if signal.entry_price <= 0:
                return False
            
            if signal.stop_loss and signal.stop_loss <= 0:
                return False
            
            if signal.take_profit and signal.take_profit <= 0:
                return False
            
            # Validate risk-reward ratio
            if signal.risk_reward_ratio and signal.risk_reward_ratio < 0.5:
                return False
            
            # Check if signal is expired
            if signal.is_expired():
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating signal: {e}")
            return False
    
    async def post_process_signal(self, signal: TradingSignal) -> TradingSignal:
        """
        Post-process signal after generation (add metadata, adjust parameters, etc.)
        """
        try:
            # Set strategy metadata
            signal.strategy_id = self.strategy_id
            
            # Add default stop loss/take profit if not set
            if not signal.stop_loss:
                if signal.is_buy_signal():
                    signal.stop_loss = signal.entry_price * (1 - self.default_stop_loss_pct)
                else:
                    signal.stop_loss = signal.entry_price * (1 + self.default_stop_loss_pct)
            
            if not signal.take_profit:
                if signal.is_buy_signal():
                    signal.take_profit = signal.entry_price * (1 + self.default_take_profit_pct)
                else:
                    signal.take_profit = signal.entry_price * (1 - self.default_take_profit_pct)
            
            # Recalculate risk-reward ratio
            if signal.stop_loss and signal.take_profit:
                risk = abs(signal.entry_price - signal.stop_loss)
                reward = abs(signal.take_profit - signal.entry_price)
                signal.risk_reward_ratio = reward / risk if risk > 0 else None
            
            # Add to signal history
            self._add_to_history(signal)
            
            # Update cooldown
            self.signal_cooldown_periods[signal.symbol] = signal.timestamp
            
            logger.debug(f"Signal post-processed for {signal.symbol}: {signal.signal_type.value} at ${signal.entry_price:.4f}")
            
            return signal
            
        except Exception as e:
            logger.error(f"Error post-processing signal: {e}")
            return signal
    
    def _add_to_history(self, signal: TradingSignal):
        """Add signal to history with size limit"""
        self.signal_history.append(signal)
        
        # Trim history if too large
        if len(self.signal_history) > self.max_history_size:
            self.signal_history = self.signal_history[-self.max_history_size:]
    
    async def update_performance(self, signal: TradingSignal, success: bool, return_pct: float = 0.0):
        """
        Update strategy performance metrics
        
        Args:
            signal: The trading signal
            success: Whether the trade was successful
            return_pct: Return percentage of the trade
        """
        try:
            self.performance.total_signals += 1
            
            if success:
                self.performance.successful_signals += 1
            else:
                self.performance.failed_signals += 1
            
            # Update win rate
            self.performance.win_rate = (self.performance.successful_signals / 
                                       self.performance.total_signals * 100)
            
            # Update average confidence
            total_confidence = (self.performance.avg_confidence * (self.performance.total_signals - 1) + 
                              signal.confidence)
            self.performance.avg_confidence = total_confidence / self.performance.total_signals
            
            # Update average quality score
            quality_score = signal.get_signal_quality_score()
            total_quality = (self.performance.avg_quality_score * (self.performance.total_signals - 1) + 
                           quality_score)
            self.performance.avg_quality_score = total_quality / self.performance.total_signals
            
            # Update total return
            self.performance.total_return += return_pct
            
            self.performance.last_updated = datetime.utcnow()
            
        except Exception as e:
            logger.error(f"Error updating performance: {e}")
    
    # Utility methods for technical analysis
    def calculate_sma(self, data: pd.Series, period: int) -> pd.Series:
        """Calculate Simple Moving Average"""
        return data.rolling(window=period).mean()
    
    def calculate_ema(self, data: pd.Series, period: int) -> pd.Series:
        """Calculate Exponential Moving Average"""
        return data.ewm(span=period).mean()
    
    def calculate_rsi(self, data: pd.Series, period: int = 14) -> pd.Series:
        """Calculate Relative Strength Index"""
        try:
            delta = data.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            return rsi
        except Exception as e:
            logger.error(f"Error calculating RSI: {e}")
            return pd.Series(index=data.index, dtype=float)
    
    def calculate_bollinger_bands(self, data: pd.Series, period: int = 20, 
                                std_multiplier: float = 2.0) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """Calculate Bollinger Bands"""
        try:
            sma = self.calculate_sma(data, period)
            std = data.rolling(window=period).std()
            upper_band = sma + (std * std_multiplier)
            lower_band = sma - (std * std_multiplier)
            return upper_band, sma, lower_band
        except Exception as e:
            logger.error(f"Error calculating Bollinger Bands: {e}")
            return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    def calculate_macd(self, data: pd.Series, fast_period: int = 12, 
                      slow_period: int = 26, signal_period: int = 9) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """Calculate MACD"""
        try:
            ema_fast = self.calculate_ema(data, fast_period)
            ema_slow = self.calculate_ema(data, slow_period)
            macd = ema_fast - ema_slow
            signal = self.calculate_ema(macd, signal_period)
            histogram = macd - signal
            return macd, signal, histogram
        except Exception as e:
            logger.error(f"Error calculating MACD: {e}")
            return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    def detect_market_condition(self, market_data: pd.DataFrame) -> MarketCondition:
        """Detect current market condition"""
        try:
            if len(market_data) < 20:
                return MarketCondition.CONSOLIDATING
            
            # Calculate trend indicators
            sma_short = self.calculate_sma(market_data['close'], 10)
            sma_long = self.calculate_sma(market_data['close'], 20)
            
            # Calculate volatility
            returns = market_data['close'].pct_change()
            volatility = returns.rolling(window=10).std().iloc[-1]
            
            # Determine trend
            current_short = sma_short.iloc[-1]
            current_long = sma_long.iloc[-1]
            prev_short = sma_short.iloc[-2]
            prev_long = sma_long.iloc[-2]
            
            trend_strength = abs(current_short - current_long) / current_long
            
            if volatility > 0.03:  # High volatility threshold
                return MarketCondition.VOLATILE
            elif trend_strength > 0.02:  # Strong trend threshold
                if current_short > current_long and prev_short < prev_long:
                    return MarketCondition.BREAKOUT
                elif current_short > current_long:
                    return MarketCondition.TRENDING_UP
                else:
                    return MarketCondition.TRENDING_DOWN
            else:
                return MarketCondition.SIDEWAYS
                
        except Exception as e:
            logger.error(f"Error detecting market condition: {e}")
            return MarketCondition.CONSOLIDATING
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """Get strategy information and current state"""
        return {
            'strategy_name': self.strategy_name,
            'strategy_id': self.strategy_id,
            'is_initialized': self.is_initialized,
            'is_active': self.is_active,
            'last_signal_time': self.last_signal_time.isoformat() if self.last_signal_time else None,
            'performance': {
                'total_signals': self.performance.total_signals,
                'win_rate': self.performance.win_rate,
                'avg_confidence': self.performance.avg_confidence,
                'avg_quality_score': self.performance.avg_quality_score,
                'total_return': self.performance.total_return,
                'last_updated': self.performance.last_updated.isoformat()
            },
            'config': self.config,
            'parameters': {
                'min_confidence_threshold': self.min_confidence_threshold,
                'max_signals_per_hour': self.max_signals_per_hour,
                'required_data_points': self.required_data_points,
                'max_risk_per_trade': self.max_risk_per_trade
            },
            'history_size': len(self.signal_history)
        }
    
    async def cleanup(self):
        """Cleanup strategy resources"""
        try:
            self.is_active = False
            logger.info(f"Strategy {self.strategy_name} cleanup completed")
        except Exception as e:
            logger.error(f"Error during strategy cleanup: {e}")

# Example implementation for testing
class ExampleStrategy(BaseStrategy):
    """Example strategy implementation for testing"""
    
    async def generate_signal(self, symbol: str, market_data: pd.DataFrame, 
                            current_price: float) -> Optional[TradingSignal]:
        """Generate a simple example signal"""
        try:
            if len(market_data) < self.required_data_points:
                return None
            
            # Simple SMA crossover strategy
            sma_short = self.calculate_sma(market_data['close'], 10)
            sma_long = self.calculate_sma(market_data['close'], 20)
            
            if len(sma_short) < 2 or len(sma_long) < 2:
                return None
            
            # Check for crossover
            if sma_short.iloc[-1] > sma_long.iloc[-1] and sma_short.iloc[-2] <= sma_long.iloc[-2]:
                # Bullish crossover
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=75.0,
                    entry_price=current_price,
                    reasoning=[
                        "SMA 10 crossed above SMA 20",
                        "Bullish momentum detected"
                    ],
                    market_condition=self.detect_market_condition(market_data),
                    strategy_id=self.strategy_id
                )
            
            elif sma_short.iloc[-1] < sma_long.iloc[-1] and sma_short.iloc[-2] >= sma_long.iloc[-2]:
                # Bearish crossover
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.SELL,
                    confidence=70.0,
                    entry_price=current_price,
                    reasoning=[
                        "SMA 10 crossed below SMA 20",
                        "Bearish momentum detected"
                    ],
                    market_condition=self.detect_market_condition(market_data),
                    strategy_id=self.strategy_id
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error generating example signal: {e}")
            return None

# Testing function
async def test_base_strategy():
    """Test the base strategy framework"""
    try:
        print("🧪 Testing Base Strategy Framework")
        print("=" * 40)
        
        # Test signal creation
        signal = TradingSignal(
            symbol="BTC/USDT",
            signal_type=SignalType.BUY,
            confidence=85.0,
            entry_price=45000.0,
            stop_loss=43500.0,
            take_profit=47000.0,
            reasoning=["Test signal", "Strong bullish momentum"],
            strategy_id="test_strategy"
        )
        
        print(f"✅ Signal created: {signal.signal_type.value} {signal.symbol}")
        print(f"   Confidence: {signal.confidence}%")
        print(f"   Quality Score: {signal.get_signal_quality_score():.1f}")
        print(f"   Risk/Reward: {signal.risk_reward_ratio:.2f}")
        print(f"   Strength: {signal.signal_strength.value}")
        
        # Test signal conversion
        signal_dict = signal.to_dict()
        recreated_signal = TradingSignal.from_dict(signal_dict)
        print(f"✅ Signal serialization test passed")
        
        # Test example strategy
        config = {
            'min_confidence_threshold': 60.0,
            'max_signals_per_hour': 5,
            'required_data_points': 25
        }
        
        strategy = ExampleStrategy(config)
        await strategy.initialize()
        
        print(f"✅ Example strategy initialized")
        
        # Generate test market data
        dates = pd.date_range(start='2024-01-01', periods=50, freq='H')
        np.random.seed(42)
        prices = 45000 + np.cumsum(np.random.randn(50) * 100)
        
        market_data = pd.DataFrame({
            'timestamp': dates,
            'open': prices * 0.999,
            'high': prices * 1.002,
            'low': prices * 0.998,
            'close': prices,
            'volume': np.random.randint(1000, 10000, 50)
        })
        
        # Test signal generation
        current_price = market_data['close'].iloc[-1]
        test_signal = await strategy.generate_signal('BTC/USDT', market_data, current_price)
        
        if test_signal:
            print(f"✅ Signal generated: {test_signal.signal_type.value} at ${test_signal.entry_price:.2f}")
            print(f"   Reasoning: {test_signal.reasoning[0] if test_signal.reasoning else 'N/A'}")
        else:
            print(f"✅ No signal generated (expected behavior)")
        
        # Test strategy info
        info = strategy.get_strategy_info()
        print(f"✅ Strategy info: {info['strategy_name']}")
        print(f"   Signals generated: {info['performance']['total_signals']}")
        
        # Cleanup
        await strategy.cleanup()
        print(f"✅ Strategy cleanup completed")
        
        print(f"\n🎉 Base Strategy Framework test completed successfully!")
        
    except Exception as e:
        print(f"❌ Error in base strategy test: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(test_base_strategy())